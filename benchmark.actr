(load "/Users/dr/Applications/actr6/load-act-r-6.lisp")

(clear-all)

(defmacro with-all-models (&body body)
  `(dolist (model-name *agent-list*)
   (let ((mp (current-mp)))
     (if mp
         (if (valid-model-name model-name)
             (let ((previous-model (current-model-struct)))
               (setf (meta-p-current-model (current-mp)) 
                 (gethash model-name (meta-p-models mp)))
               (unwind-protect (progn ,@body)
		 (setf (meta-p-current-model (current-mp)) previous-model)
               ))
           (print-warning "~S does not name a model in the current meta-process (wiht-all-models)" model-name))
       (print-warning "No actions taken in with-model because there is no current meta-process")))))



; ==============================================================
; MEANING SPACE
; ===============================================================

(defun reset-meaning-space (concept-names &optional noise)
  (let ((concept-list))
    (dolist (cname  concept-names)
      (with-all-models   
	(add-dm-fct (list (list 
			   cname
			   'isa 'concept
			   'meaning cname )))
	)
	  
      ;; and create association network
      ;; we want all models to have the same common ground

      ;;    (print "setting associations...")
      (with-all-models 
	(add-sji-fct (list (list cname cname 1.0))))
      (loop for cname2 in concept-list do
	   (let ((sim (+  (* 0.001 (random 1 my-random-state))))) ;; ensure that assoc overpower base-level  (maybe +50 ?)
	     (unless (eq cname cname2)
	       (with-all-models 
		   (let ((simn (if (eq noise 'max)
				   ;; noise==max: every model has its own
				   (* 0.001 (random 1 my-random-state))
				   ;; otherwise, just add the noise
				   (+ sim (*  (or noise 0) (act-r-noise 1))))))
		     (add-sji-fct (list (list cname cname2 simn) 
					(list cname2 cname simn))))) 
	       )))

      (setq concept-list (cons cname concept-list))))
  (mp-wait-for 1000) ;; let activation settle.
  )



; BENCHMARK


(defvar *number-of-concepts*  1000)
(reset-meaning-space (loop for i from 1 to *number-of-concepts* collect 
			  (intern (string-upcase (format nil "concept~a" i)))))

(define-model benchmark

	(sgp :esc t) ; subsymbolic system

(chunk-type bechmarking state cue1 cue2 cue3)

(chunk-type concept meaning)


;; what's a fair comparison?
;; should we simply pick the three concepts at random
;; or should we utilize the ACT-R 
(P request-concept
    ==>
   !eval! (start-new-drawing =COMP1)

   +goal>
   ISA benchmarking
   state retrieving
   cue1  =CUE1
   cue2  =CUE2
   cue3  =CUE3

   +retrieval>
   ISA concept
  - agenda-component-1 none
    agenda-component-1 =COMP1
    agenda-component-2 =COMP2
    agenda-component-3 =COMP3
   )

