<html><head><title>ACT-UP</title></head><body><h3>API for package ACT-UP</h3>
<blockquote>The ACT-UP library.  Defines a number of functions
and macros implementing the ACT-R theory (Anderson 1993, Anderson et al. 1998,
Anderson 2007, etc.).
 (C) 2010, David Reitter, Carnegie Mellon University.</blockquote>
<a name="*all*" /><p><b>*all*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Constant for <a href="#*debug*">*debug*</a>: Show all messages (maximum detail).</blockquote>
<blockquote>Initial value: <tt>1000</tt></blockquote>
<a name="*alpha*" /><p><b>*alpha*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Utility learning rate.
See also the function <a href="#assign-reward">assign-reward</a>.
See also: ACT-R parameter :alpha</blockquote>
<blockquote>Initial value: <tt>0.2</tt></blockquote>
<a name="*ans*" /><p><b>*ans*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Transient noise parameter for declarative memory.
See also: ACT-R parameter :ans</blockquote>
<blockquote>Initial value: <tt>0.2</tt></blockquote>
<a name="*associative-learning*" /><p><b>*associative-learning*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>The trigger for associative learning, a in ROM Equation 4.5.
<pre>
   Can be any non-negative value.</pre></blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*au-rfr*" /><p><b>*au-rfr*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>base reward proportion for each rule
e.g., the each rule before the reward trigger gets 10% of the reward.
Set to nil (default) to use the ACT-R discounting by time in seconds.
See also the parameter <a href="#*au-rpps*">*au-rpps*</a> and the function <a href="#assign-reward">assign-reward</a>.</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*au-rpps*" /><p><b>*au-rpps*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Reward proportion per second elapsed.
e.g., after 10 seconds we want to assign 50% of the remaining reward: 0.5/10 = 0.05
time is in between rules.
Set to nil (default) to use the ACT-R discounting by time in seconds.
See also the parameter <a href="#*au-rfr*">*au-rfr*</a> and the function <a href="#assign-reward">assign-reward</a>.</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*blc*" /><p><b>*blc*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Base-level constant parameter for declarative memory.
See also: ACT-R parameter :blc</blockquote>
<blockquote>Initial value: <tt>0.0</tt></blockquote>
<a name="*bll*" /><p><b>*bll*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Base-level learning decay parameter for declarative memory.
See also: ACT-R parameter :bll</blockquote>
<blockquote>Initial value: <tt>0.5</tt></blockquote>
<a name="*critical*" /><p><b>*critical*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Constant for <a href="#*debug*">*debug*</a>: Show only critical messages.</blockquote>
<blockquote>Initial value: <tt>0</tt></blockquote>
<a name="*current-actup-meta-process*" /><p><b>*current-actup-meta-process*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>The current ACT-UP meta-process.
The meta process keeps track of simulation time.
May be read and manipulated by setting it to a different
instance of type <a href="#meta-process">meta-process</a>.</blockquote>
<blockquote>Initial value: <tt>#S(ACT-UP:META-PROCESS :ACTUP-TIME 0.0 :NAME NIL)</tt></blockquote>
<a name="*dat*" /><p><b>*dat*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Default time that it takes to execut an ACT-UP rule in seconds.
See also: ACT-R parameter :dat  [which pertains to ACT-R productions]</blockquote>
<blockquote>Initial value: <tt>0.05</tt></blockquote>
<a name="*debug*" /><p><b>*debug*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Level of debug output currently in effect.
The following constants may be used:

*critical* *warning* *informational* *all*

The parameter <a href="#*debug-to-log*">*debug-to-log*</a> is helpful in logging debug messages to a file.</blockquote>
<blockquote>Initial value: <tt>10</tt></blockquote>
<a name="*debug-to-log*" /><p><b>*debug-to-log*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Enable off-screen logging of debug output.
If t, ACT-UP logs all debug messages not to standard output,
but to a buffer that can be read with <a href="#debug-log">debug-log</a> and cleared with <a href="#debug-clear">debug-clear</a>.
If a stream, ACT-UP logs to the stream.</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*detailed*" /><p><b>*detailed*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Constant for <a href="#*debug*">*debug*</a>: Show detailed log output .</blockquote>
<blockquote>Initial value: <tt>300</tt></blockquote>
<a name="*egs*" /><p><b>*egs*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Transient noise parameter for ACT-UP rules.

This is the expected gain s parameter. It specifies the s parameter
for the noise added to the utility values. It defaults to 0 which
means there is no noise in utilities.

See also: ACT-R parameter :egs</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*epl*" /><a name="*informational*" /><p><b>*informational*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Constant for <a href="#*debug*">*debug*</a>: Show informational and more important messages.</blockquote>
<blockquote>Initial value: <tt>100</tt></blockquote>
<a name="*iu*" /><p><b>*iu*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Initial rule utility.

The initial utility value for a user-defined rule (<a href="#defrule">defrule</a>). This is
the U(0) value for a production if utility learning is enabled and the
default utility if learning (<a href="#*ul*">*ul*</a>) is not enabled. The default value
is 0.

See also the function <a href="#assign-reward">assign-reward</a>.
See also: ACT-R parameter :iu</blockquote>
<blockquote>Initial value: <tt>0.0</tt></blockquote>
<a name="*le*" /><p><b>*le*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Latency Exponent parameter for declarative retrieval time calculation.
See ACT-R parameter :le</blockquote>
<blockquote>Initial value: <tt>1.0</tt></blockquote>
<a name="*lf*" /><p><b>*lf*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Latency Factor parameter for declarative retrieval time calculation.
See ACT-R parameter :lf</blockquote>
<blockquote>Initial value: <tt>1.0</tt></blockquote>
<a name="*mas*" /><a name="*maximum-associative-strength*" /><p><b>*maximum-associative-strength*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Maximum associative strength parameter for Declarative Memory.
<a href="#*mas*">*mas*</a> is defined as alias for <a href="#maximum-associative-strength">maximum-associative-strength</a>.
See also <a href="#*associative-learning*">*associative-learning*</a>, <a href="#reset-sji-fct">reset-sji-fct</a>.
See also: ACT-R parameter :mas.</blockquote>
<blockquote>Initial value: <tt>1.0</tt></blockquote>
<a name="*md*" /><p><b>*md*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>ACT-UP Partial Match Maximum Difference
Similarity penalty assigned when chunks are different
and no explicit similarity is set.
Value in activation (log) space.</blockquote>
<blockquote>Initial value: <tt>-1</tt></blockquote>
<a name="*mp*" /><p><b>*mp*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>ACT-UP Partial Match Scaling parameter
Mismatch (<a href="#set-similarities-fct">set-similarities-fct</a>) is linearly scaled using this coefficient.</blockquote>
<blockquote>Initial value: <tt>1.0</tt></blockquote>
<a name="*ms*" /><p><b>*ms*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>ACT-UP Partial Match Maximum Similarity
Similarity penalty assigned when chunks are equal.
Value in activation (log) space.</blockquote>
<blockquote>Initial value: <tt>0</tt></blockquote>
<a name="*nu*" /><p><b>*nu*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Utility assigned to compiled rules.

This is the starting utility for a newly learned rule (those created
by the production compilation mechanism). This is the U(0) value for
such a rule if utility learning is enabled and the default utility if
learning is not enabled. The default value is 0.

See also the function <a href="#assign-reward">assign-reward</a> and the variable <a href="#*rule-compilation*">*rule-compilation*</a>.
See also: ACT-R parameter :nu</blockquote>
<blockquote>Initial value: <tt>0.0</tt></blockquote>
<a name="*ol*" /><p><b>*ol*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Optimized Learning parameter for base-level learning in Declarative Memory.
OL is always on in ACT-UP.
See also: ACT-R parameter :ol</blockquote>
<blockquote>Initial value: <tt>3</tt></blockquote>
<a name="*pas*" /><p><b>*pas*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Permanent noise parameter for declarative memory.
See also: ACT-R parameter :pas</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*rt*" /><p><b>*rt*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Retrieval Threshold parameter for declarative memory.
Chunks with activation lower than <a href="#*rt*">*rt*</a> are not retrieved.
See also: ACT-R parameter :rt</blockquote>
<blockquote>Initial value: <tt>0.0</tt></blockquote>
<a name="*rule-compilation*" /><p><b>*rule-compilation*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>If non-nil, rule compilation is enabled.
Rule compilation causes ACT-UP rules defined with <a href="#defrule">defrule</a> to be compiled (or: cached).
After execution of a source rule,  name, execution arguments and the result are stored as
compiled rule.  The compiled rule is added to each of the source rule's groups.

When the group is executed, compiled rules compete for execution with the other rules in the group.  (The rule with the highest utility is chosen.)

The initial utility of a compiled rule equals the initial utility of the source rule.  When a source rule is compiled multiple times, the utility of the compiled rule is updated by assigning the source rule utility as reward to the compiled rule (according to the ACT-R difference learning equation).  See also <a href="#assign-reward">assign-reward</a> for reward assignment to regular rules.

<a href="#*epl*">*epl*</a> is defined as alias for <a href="#*rule-compilation*">*rule-compilation*</a>.</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*ul*" /><p><b>*ul*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Utility learning flag.

If this is set to t, then the utility learning equation used above
will be used to learn the utilities as the model runs. If it is set to
nil then the explicitly set utility values for the rules are
used (though the noise will still be added if <a href="#*egs*">*egs*</a> is
non-zero). The default value is nil.

See also the function <a href="#assign-reward">assign-reward</a>.
Only if <a href="#assign-reward">assign-reward</a> is called will this parameter have any effect.

See also: ACT-R parameter :ul</blockquote>
<blockquote>Initial value: <tt>T</tt></blockquote>
<a name="*ut*" /><p><b>*ut*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Utility threshold.

This is the utility threshold. If it is set to a number then that is
the minimum utility value that a rule must have to compete in
conflict resolution. Rules with a lower utility value than that
will not be selected. The default value is nil which means that there
is no threshold value and all rules will be considered.

See also: ACT-R parameter :ut</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*warning*" /><p><b>*warning*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Constant for <a href="#*debug*">*debug*</a>: Show warnings and more important messages.</blockquote>
<blockquote>Initial value: <tt>10</tt></blockquote>
<a name="actup-chunk" /><p><b>actup-chunk</b>&nbsp;&nbsp;&nbsp;<i>structure</i></p>
<blockquote>Type defining an ACT-UP chunk.
Derive your own chunks using this as a base structure
by using <a href="#define-chunk">define-chunk</a>.</blockquote><a name="actup-time" /><p>(<b>actup-time</b> &optional meta-process)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Returns the current runtime.
An optional parameter META-PROCESS specifies the meta-process to use.
It defaults to the current meta-process.</blockquote><a name="add-sji-fct" /><p>(<b>add-sji-fct</b> list)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Set Sji link weights between chunks.
LIST is a list with elements of form (CJ NI S), where CJ und NI are
chunks or chunk names, and S is the new link weight, regulating
spreading activation when CI is in context as a cue and NI is
retrieved.  S may also be a list of form (FCN TIME), with FCN
indicating frequency of C and N occurring together, and TIME
indicating the point in time of their last joint occurrence (TIME is
unused currently, but must be given.)</blockquote><a name="assign-reward" /><p>(<b>assign-reward</b> reward)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Assign reward to recently invoked rules.
Distributes reward value REWARD across the recently invoked rules.
See parameters <a href="#*au-rpps*">*au-rpps*</a>, <a href="#*au-rfr*">*au-rfr*</a>, <a href="#*alpha*">*alpha*</a>, and <a href="#*iu*">*iu*</a>.
See <a href="#defrule">defrule</a> for documentation on how to use utility when
selecting between rules.

Reward must be greater than 0.

The reward is only distributed to rules invoked since the last call to
<a href="#assign-reward">assign-reward</a> (or <a href="#flush-rule-queue">flush-rule-queue</a>, or <a href="#reset-model">reset-model</a>).  See also
<a href="#assign-reward*">assign-reward*</a> for a function that does not reset this set of
rules.</blockquote><a name="assign-reward*" /><p>(<b>assign-reward*</b> reward)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Like <a href="#assign-reward">assign-reward</a>, but does not flush the rule queue.
Only reward portions >0 are assigned to rules, i.e., if
<a href="#*au-rfr*">*au-rfr*</a> or <a href="#*au-rpps*">*au-rpps*</a> are nil (ACT-R 6 reward propagation),
rewards are only assigned to rules up to <a href="#reward">reward</a> seconds back in time.
See also <a href="#flush-rule-queue">flush-rule-queue</a>.</blockquote><a name="best-chunk" /><p>(<b>best-chunk</b> confusion-set cues &optional request-spec timeout &rest options)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Retrieves the best chunk in confusion set.
CONFUSION-SET is a list of chunks, out of which the chunk is returned.
CUES is a list of cues that spread activation.  CUES may contain
chunk objects or names of chunks.
OPTIONS: do not use (yet).

Simulates timing behavior.

See also the higher-level function <a href="#retrieve-chunk">retrieve-chunk</a>.</blockquote><a name="blend" /><p>(<b>blend</b> chunks &optional cues chunk-type retrieval-spec)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Return a blended variant of chunks.
Activation is calculated using spreading activation from CUES.  CUES
may contain chunk objects or names of chunks.  The returned chunk is
of type CHUNK-TYPE; all CHUNKS must be of type CHUNK-TYPE or of a
supertype thereof.  If CHUNK-TYPE is not given, all CHUNKS must be of
the same class and the returned type will be this class.
RETRIEVAL-SPEC should contain the retrieval filter used to obtain
CHUNKS; attribute-value pairs in it will be included in the returned
chunk as-is and not be blended from the CHUNKS.

See also the higher-level function <a href="#blend-retrieve-chunk">blend-retrieve-chunk</a>.</blockquote><a name="blend-retrieve-chunk" /><p>(<b>blend-retrieve-chunk</b> spec &optional cues pm-soft-spec)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Retrieve a blended chunk from declarative memory.
The blended chunk is a new chunk represeting the chunks
retrievable from declarative memory under specification SPEC.
The contents of the blended chunk consist of a weighted average
of the retrievable chunks, whereas each chunk is weighted
according to its activation.

CUES is, if given, a list of chunks that spread activation
to facilitate the retrieval of target chunks. CUES may contain
chunk objects or names of chunks.

PM-SOFT-SPEC is, if given, a retrieval specification whose 
constraints are soft; partial matching is used for this portion
of the retrieval specification. 

SPEC and PM-SOFT-SPEC are lists of the form (:slot1 value1 :slot2
value2 ...), or (slot1 value1 slot2 value2).</blockquote><a name="chunk-name" /><a name="chunk-type" /><a name="current-model" /><p>(<b>current-model</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Evaluates to the currently active ACT-UP model.</blockquote><a name="debug-clear" /><p>(<b>debug-clear</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Clear the ACT-UP debug log buffer.</blockquote><a name="debug-detail" /><p>(<b>debug-detail</b> &body body)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Evaluates BODY while outputting ACT-UP debug information.</blockquote><a name="debug-detail*" /><p>(<b>debug-detail*</b> &body body)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Evaluates BODY while logging ACT-UP debug information.
The log output can be retrieved with <a href="#debug-log">debug-log</a>.</blockquote><a name="debug-grep" /><p>(<b>debug-grep</b> keyword &body body)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Evaluates BODY while outputting ACT-UP debug information.</blockquote><a name="debug-log" /><p>(<b>debug-log</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Returns logged ACT-R output.
If <a href="#*debug-to-log*">*debug-to-log*</a> is set to t, the ACT-UP debug log may be
retrieved using this function.</blockquote><a name="define-chunk-type" /><p>(<b>define-chunk-type</b> type &rest members)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Define a chunk type of name TYPE.
MEMBERS should contain all possible elements of the chunk type.
TYPE may be a symbol or a list of form (name2 :include parent-type),
whereas PARENT-TYPE refers to another defined chunk type whose
elements will be inherited.
MEMBERS may be a list of symbols, or also a list of member
specifiers as used with the lisp <a href="#defstruct">defstruct</a> macro, which see.
<pre>
  </pre>
Chunks make be created by invoking the make-TYPE function, whereas
TYPE stands for the name of the chunk type as defined with this
macro. An attribute called <a href="#:name">:name</a> should be included to specify the
unique name of the chunk (the name may not be used for any other chunk
in the model). 

Chunk contents must not be changed after a chunk has been created.

An additional function of name make-TYPE* is also provided, which
creates a new chunk just like make-TYPE does, but only if such a chunk
does not yet exist in declarative memory (of the current model). All
slot values of the chunks are used in the comparison (unspecified ones
at their default values), except the :name attribute.  If a matching
chunk is found in DM, it is returned.</blockquote><a name="define-slots" /><p>(<b>define-slots</b> &rest slot-names)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Define slots to be used in chunks of this process.
Only slot names defined using this macro may be used in chunks.
Overrides any slot set defined earlier.</blockquote><a name="defrule" /><p>(<b>defrule</b> name args &rest body)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Define an ACT-UP rule.
The syntax follows the Lisp <a href="#defun">defun</a> macro, except that 
some keyword-argument parameters may follow ARGS
at the beginning of BODY.

This macro will define a Lisp function of name NAME with
arguments ARGS.  The Lisp function will execute the Lisp
forms in BODY and return the value of the last form.

The known parameters are:

<pre>
 :GROUP the-group</pre>
A :group parameter defines one or or a list of rule
groups that the rule will belong to.  All rules defined as part of a
group must have the same argument footprint.


If GROUP is given, a function of name GROUP will also be
defined that invokes one of the rules assigned to GROUP.
For example:

<pre>
 (defrule subtract-digit-by-addition (minuend subtrahend)
   :group subtract
   "Perform subtraction of a single digit via addition."
   (let ((chunk (retrieve-chunk #96;(:chunk-type addition-fact
                                  :result ,minuend
                                  :add1 ,subtrahend))))
       (if chunk (addition-fact-add2 chunk))))
 (defrule subtract-digit-by-decrement (minuend subtrahend)
   :group subtract
   "Perform subtraction of a single digit via subtraction knowledge."
   ...)</pre>

These rules can be invoked via a function call such as

<pre>
 (subtract 5 2)</pre>

ACT-Up will choose the rule that has the highest utility.  See
<a href="#assign-reward">assign-reward</a> for manipulation of utilities (reinforcement
learning), and <a href="#*rule-compilation*">*rule-compilation*</a> for in-theory compilation of
rules (routinization, internalization).

<pre>
 :INITIAL-UTILITY u</pre>

The :initial-utility parameter sets the utility that this rule receives when it is created or the model is reset.
If not given, the initial utility will be the value of <a href="#*iu*">*iu*</a> at time of first invocation.

Rule utilities, wether initial or acquired through rewards are always specific to the model.

Rules and groupings of rules are not specific to the model.</blockquote><a name="explain-activation" /><p>(<b>explain-activation</b> chunk-or-name &optional cues retr-spec)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Returns a string with an explanation of the evaluation of CHUNK.
CUES contains retrieval cues spreading activation.
RETR-SPEC describes the retrieval specification for partial matching retrievals.</blockquote><a name="filter-chunks" /><p>(<b>filter-chunks</b> chunk-set args)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Filter chunks according to ARGS.
ARGS is a list of the form (:slot1 value1 :slot2 value2 ...),
or (slot1 value1 slot2 value2).
CHUNK-SET is the list of chunks to be filtered (1), or an associative array (2)
of the form ((X . chunk1) (Y . chunk2) ...).
returns a list of chunks in case (1) and a list of conses in case (2).</blockquote><a name="flush-rule-queue" /><p>(<b>flush-rule-queue</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Empties the queue of rules in the current model.
This resets the list of rules to which rewards can be distributed (see
<a href="#assign-reward">assign-reward</a> and <a href="#assign-reward*">assign-reward*</a>.</blockquote><a name="learn-chunk" /><p>(<b>learn-chunk</b> chunk &optional co-presentations)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Learn chunk CHUNK.

This will note a presentation of an existing chunk in the model's DM, if
the existing chunk is unifiable with CHUNK.  If no such chunk exists in DM,
the CHUNK will be added.  If more than one such chunk exists, one of the existing
chunks is noted as 'presented'.

CHUNK may be altered by side-effect.

Returns the added chunk.</blockquote><a name="make-chunk" /><p>(<b>make-chunk</b> &rest args)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Create an ACT-UP chunk.
Arguments should consist of named chunk feature values: ARGS is a list
of the form (:name1 val1 :name2 val2 ...), whereas names correspond to
slot names as defined with <a href="#define-slots">define-slots</a>.  

An attribute called <a href="#:name">:name</a> should be included to specify the unique
name of the chunk (the name may not be used for any other chunk in
the model). 

If chunk types are defined with <a href="#define-chunk-type">define-chunk-type</a>, then use the
<a href="#make-TYPE">make-TYPE</a> syntax instead.</blockquote><a name="make-chunk*" /><p>(<b>make-chunk*</b> &rest args)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Like <a href="#make-chunk">make-chunk</a>, but returns matching chunk from declarative memory if one exists.

Arguments should consist of named chunk feature values: ARGS is a list
of the form (:name1 val1 :name2 val2 ...), whereas names correspond to
slot names as defined with <a href="#define-slots">define-slots</a>.  

An attribute called <a href="#:name">:name</a> should be included to specify the 
name of the chunk. Comparing the proposed chunks (in ARGS) to the existing
chunks in Declarative Memory, the names of the chunks are ignored.

The purpose of this function lies in the ability to boost a chunk existing in DM, when its contents are already known. For example:

<pre>
 (reset-model)
 (learn-chunk (make-chunk* :one 1 :two 2))
 (learn-chunk (make-chunk* :one 1 :two 2))</pre>

will create a chunk (first call), and then boost it, while

<pre>
 (learn-chunk (make-chunk :one 1 :two 2))</pre>

will always create new chunk and add it to declarative memory.

If chunk types are defined with <a href="#define-chunk-type">define-chunk-type</a>, then use the
<a href="#make-TYPE*">make-TYPE*</a> syntax instead.</blockquote><a name="make-meta-process" /><p><b>MAKE-META-PROCESS</b></p>&nbsp;&nbsp;&nbsp;<i><font color="FF0000">undocumented</font></i></p>
<a name="make-model" /><p><b>MAKE-MODEL</b></p>&nbsp;&nbsp;&nbsp;<i><font color="FF0000">undocumented</font></i></p>
<a name="meta-process" /><p><b>meta-process</b>&nbsp;&nbsp;&nbsp;<i>structure</i></p>
<blockquote>An ACT-UP meta process.
A meta process keeps track of time for one or more models.</blockquote><a name="meta-process-name" /><p><b>META-PROCESS-NAME</b></p>&nbsp;&nbsp;&nbsp;<i><font color="FF0000">undocumented</font></i></p>
<a name="model-chunks" /><p>(<b>model-chunks</b> model)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Evaluates to the list of chunks in the given model MODEL.</blockquote><a name="model-name" /><p><b>MODEL-NAME</b></p>&nbsp;&nbsp;&nbsp;<i><font color="FF0000">undocumented</font></i></p>
<a name="module-busy-p" /><p>(<b>module-busy-p</b> symbol)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Determine whether module belonging to object SYMBOL is busy.
SYMBOL may be the name of an ACT-UP module, 
it may be an ACT-UP function belonging to a module,
or it may be a result variable assigned with <a href="#request-bind">request-bind</a>.</blockquote><a name="non-nil" /><a name="pass-time" /><p>(<b>pass-time</b> seconds &optional meta-process)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Simulates the passing of time.
An optional parameter META-PROCESS specifies the meta-process to use.
It defaults to the current meta-process.</blockquote><a name="pc" /><p>(<b>pc</b> stream obj)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Print a human-readable representation of chunk OBJ to STREAM.
Set stream to t to output to standard output.</blockquote><a name="receive" /><p>(<b>receive</b> handle)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Receive result from request HANDLE.
Waits until the result is available.
HANDLE is the handle obtained when the
request was sent via a function such as
<a href="#request-retrieve-chunk">request-retrieve-chunk</a>.</blockquote><a name="request" /><p>(<b>request</b> module-name command args)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Runs ACT-UP expression (COMMAND . ARGS) asynchronuously.</blockquote><a name="request-best-chunk" /><p>(<b>request-best-chunk</b> confusion-set cues &optional request-spec timeout &rest options)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Call <a href="#BEST-CHUNK">BEST-CHUNK</a> asynchronuously.
Initiates execution of the BEST-CHUNK function.

If the DECLARATIVE module is busy at the current time,
wait until module is free.  The module will be busy and unavailable
for other processing until the current operation has finished.

See also <a href="#receive">receive</a>.</blockquote><a name="request-filter-chunks" /><p>(<b>request-filter-chunks</b> chunk-set args)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Call <a href="#FILTER-CHUNKS">FILTER-CHUNKS</a> asynchronuously.
Initiates execution of the FILTER-CHUNKS function.

If the DECLARATIVE module is busy at the current time,
wait until module is free.  The module will be busy and unavailable
for other processing until the current operation has finished.

See also <a href="#receive">receive</a>.</blockquote><a name="request-retrieve-chunk" /><p>(<b>request-retrieve-chunk</b> spec &optional cues pm-soft-spec timeout)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Call <a href="#RETRIEVE-CHUNK">RETRIEVE-CHUNK</a> asynchronuously.
Initiates execution of the RETRIEVE-CHUNK function.

If the DECLARATIVE module is busy at the current time,
wait until module is free.  The module will be busy and unavailable
for other processing until the current operation has finished.

See also <a href="#receive">receive</a>.</blockquote><a name="reset-model" /><p>(<b>reset-model</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Resets the current ACT-UP model. 
All declarative memory and all subsymbolic knowledge is deleted.
Global parameters (dynamic, global Lisp variables) are retained, as are
functions and model-independent rules.</blockquote><a name="reset-module" /><p>(<b>reset-module</b> module-name)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Reset module MODULE-NAME.
MODULE-NAME is typically one of <a href="#procedural">procedural</a>, <a href="#declarative">declarative</a>.
Ongoing operations are terminated; their results will 
not become available to the requesters.</blockquote><a name="reset-mp" /><p>(<b>reset-mp</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Resets the current Meta process. 
Resets the time in the meta process.</blockquote><a name="reset-sji-fct" /><p>(<b>reset-sji-fct</b> chunk)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Removes all references to CHUNK from all other chunks in the current model.</blockquote><a name="response-available-p" /><p>(<b>response-available-p</b> handle)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Returns non-nil if the request associated with HANDLE has terminated.
See <a href="#request">request</a> functions.</blockquote><a name="retrieve-chunk" /><p>(<b>retrieve-chunk</b> spec &optional cues pm-soft-spec timeout)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Retrieve a chunk from declarative memory.
The retrieved chunk is the most highly active chunk among those in
declarative memory that are retrievable and that conform to
specification SPEC.

CUES is, if given, a list of chunks that spread activation
to facilitate the retrieval of a target chunk.  CUES may contain
chunk objects or names of chunks.

PM-SOFT-SPEC is, if given, a retrieval specification whose 
constraints are soft; partial matching is used for this portion
of the retrieval specification. 

SPEC and PM-SOFT-SPEC are lists of the form (:slot1 value1 :slot2
value2 ...), or (slot1 value1 slot2 value2).

TIMEOUT, if given, specifies the maximum time allowed before
the retrieval fails.</blockquote><a name="set-base-level-fct" /><p>(<b>set-base-level-fct</b> chunk value &optional creation-time)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Set base levels of CHUNK.
If CREATION-TIME is specified, it contains the time at which the chunk
was created in declarative memory, and VALUE contains the number of
presentations (an integer value).  If TIME is not specified, VALUE is
the chunk's absolute activation value (log space).

For plausibility reasons, models should specify presentations and time
when possible.</blockquote><a name="set-base-levels-fct" /><p>(<b>set-base-levels-fct</b> list)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Set base levels of several chunks.
ACT-R compatibility function.
LIST contains elements of form (CHUNK PRES TIME) or (CHUNK ACT),
whereas CHUNK is a chunk object or the name of a chunk,
PRES is a number of past presentations (integer),
and TIME the life time of the chunk,
and ACT the chunk's absolute activation.

For plausibility reasons, models should not use the ACT form when
possible.</blockquote><a name="set-current-model" /><p>(<b>set-current-model</b> new-model)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Switches the currently active ACT-UP model.
This may set a range of model parameters.</blockquote><a name="set-dm-total-presentations" /><p>(<b>set-dm-total-presentations</b> npres)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Set the count of total presentations of all chunks in DM.
This value is relevant for associative learning (Sji/Rji).</blockquote><a name="set-similarities-fct" /><p>(<b>set-similarities-fct</b> list)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Set similarities between chunks.
LIST is a list with elements of form (A B S), where A und B are
chunks or chunk names, and S is the new similarity of A and B.
For example:

<pre>
 (set-similarities-fct &#39;((dave david -0.05) 
                         (steve hank -0.1)  
                         (mary john -0.9)))</pre></blockquote><a name="show-chunks" /><p>(<b>show-chunks</b> model &optional constraints)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Prints all chunks in model MODEL subject to CONSTRAINTS.
See the function <a href="#filter-chunks">filter-chunks</a> for a description of possible constraints.</blockquote><a name="show-utilities" /><p>(<b>show-utilities</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Prints a list of all utilities in the current model.</blockquote><a name="stop-actup-time" /><p>(<b>stop-actup-time</b> &body body)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Returns execution time of BODY in current ACT-UP model.
Evaluates BODY.  See also <a href="#actup-time">actup-time</a>.</blockquote><a name="terminate-request" /><p><b>TERMINATE-REQUEST</b></p>&nbsp;&nbsp;&nbsp;<i><font color="FF0000">undocumented</font></i></p>
<a name="wait-for-model" /><p>(<b>wait-for-model</b> &optional model)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Waits until meta-process and MODEL are synchronized.
When a model is assigned a new meta-process, it can happen that
the meta-process time is behind the model's time (since the model
was operated with a different meta-process before).
This function waits (see <a href="#pass-time">pass-time</a>) until the model is ready, that
is, it sets the meta process time to the model time if the model time
is more advanced, plus the current value of <a href="#*dat*">*dat*</a>.
MODEL defaults to the current model.</blockquote><a name="wait-for-module" /><p>(<b>wait-for-module</b> module-name &optional timeout)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Waits until module associated with MODULE-SYM has finished its current operation.
MODUL-SYM may be the name of an ACT-UP module, 
it may be an ACT-UP function belonging to a module,
or it may be a result variable assigned with <a href="#request-bind">request-bind</a>.

If TIMEOUT is given, never waits longer than that.</blockquote><a name="wait-for-response" /><p><b>WAIT-FOR-RESPONSE</b></p>&nbsp;&nbsp;&nbsp;<i><font color="FF0000">undocumented</font></i></p>
<a name="with-current-model" /><p>(<b>with-current-model</b> model &body body)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Execute forms in BODY with the ACT-UP model MODEL being current.</blockquote><font size=-1><p>Documentation generated by <a href="http://homepage.mac.com/svc/lispdoc/">lispdoc</a> running on Clozure Common Lisp</p></font></body></html>