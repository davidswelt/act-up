<html><head><title>ACT-UP</title></head><body><h3>API for package ACT-UP</h3>
<blockquote>The ACT-UP library.  Defines a number of functions
and macros implementing the ACT-R theory (Anderson 1993, Anderson et al. 1998,
Anderson 2007, etc.).
 (C) 2010, David Reitter, Carnegie Mellon University.</blockquote>
<a name="*act-up-version*" /><p><b>*act-up-version*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Version of a loaded ACT-UP.
ACT-UP has been correctly initialized if this is defined and non-nil.</blockquote>
<blockquote>Initial value: <tt>0.1</tt></blockquote>
<a name="*all*" /><p><b>*all*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Constant for <a href="#*debug*">*debug*</a>: Show all messages (maximum detail).</blockquote>
<blockquote>Initial value: <tt>1000</tt></blockquote>
<a name="*alpha*" /><p><b>*alpha*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Utility learning rate.
See also the function <a href="#assign-reward">assign-reward</a>.
See also: ACT-R parameter :alpha</blockquote>
<blockquote>Initial value: <tt>0.2</tt></blockquote>
<a name="*ans*" /><p><b>*ans*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Transient noise parameter for declarative memory.
See also: ACT-R parameter :ans</blockquote>
<blockquote>Initial value: <tt>0.2</tt></blockquote>
<a name="*associative-learning*" /><p><b>*associative-learning*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>The trigger for associative learning, a in ROM Equation 4.5.
<pre>
   Can be any non-negative value.</pre></blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*au-rfr*" /><p><b>*au-rfr*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>base reward proportion for each procedure
e.g., the each procedure before the reward trigger gets 10% of the reward.
Set to nil (default) to use the ACT-R discounting by time in seconds.
See also the parameter <a href="#*au-rpps*">*au-rpps*</a> and the function <a href="#assign-reward">assign-reward</a>.</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*au-rpps*" /><p><b>*au-rpps*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Reward proportion per second elapsed.
e.g., after 10 seconds we want to assign 50% of the remaining reward: 0.5/10 = 0.05
time is in between procedures.
Set to nil (default) to use the ACT-R discounting by time in seconds.
See also the parameter <a href="#*au-rfr*">*au-rfr*</a> and the function <a href="#assign-reward">assign-reward</a>.</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*blc*" /><p><b>*blc*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Base-level constant parameter for declarative memory.
See also: ACT-R parameter :blc</blockquote>
<blockquote>Initial value: <tt>0.0</tt></blockquote>
<a name="*bll*" /><p><b>*bll*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Base-level learning decay parameter for declarative memory.
See also: ACT-R parameter :bll</blockquote>
<blockquote>Initial value: <tt>0.5</tt></blockquote>
<a name="*critical*" /><p><b>*critical*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Constant for <a href="#*debug*">*debug*</a>: Show only critical messages.</blockquote>
<blockquote>Initial value: <tt>0</tt></blockquote>
<a name="*current-actup-meta-process*" /><p><b>*current-actup-meta-process*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>The current ACT-UP meta-process.
The meta process keeps track of simulation time.
May be read and manipulated by setting it to a different
instance of type <a href="#meta-process">meta-process</a>.</blockquote>
<blockquote>Initial value: <tt>#S(META-PROCESS :ACTUP-TIME 0.0D0 :NAME NIL)</tt></blockquote>
<a name="*dat*" /><p><b>*dat*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Default time that it takes to execut an ACT-UP procedure in seconds.
See also: ACT-R parameter :dat  [which pertains to ACT-R productions]</blockquote>
<blockquote>Initial value: <tt>0.05</tt></blockquote>
<a name="*debug*" /><p><b>*debug*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Level of debug output currently in effect.
The following constants may be used:

*critical* *warning* *informational* *all*

The parameter <a href="#*debug-to-log*">*debug-to-log*</a> is helpful in logging debug messages to a file.</blockquote>
<blockquote>Initial value: <tt>10</tt></blockquote>
<a name="*debug-to-log*" /><p><b>*debug-to-log*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Enable off-screen logging of debug output.
If t, ACT-UP logs all debug messages not to standard output,
but to a buffer that can be read with <a href="#debug-log">debug-log</a> and cleared with <a href="#debug-clear">debug-clear</a>.
If a stream, ACT-UP logs to the stream.</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*declarative-finst-span*" /><p><b>*declarative-finst-span*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Declarative Finst time span

The maximum time period during whichg a finst marks a chunk as recently retrieved.
Chunks retrieved longer ago are not considered 'recently retrieved'.

Time in seconds, defaults to 3.0.

See ACT-R parameter :declarative-finst-span</blockquote>
<blockquote>Initial value: <tt>3.0</tt></blockquote>
<a name="*declarative-num-finsts*" /><p><b>*declarative-num-finsts*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Number of Declarative Finsts

The maximum number of chunks considered recently retrieved.

Defaults to 4.

See ACT-R parameter :declarative-num-finsts</blockquote>
<blockquote>Initial value: <tt>4</tt></blockquote>
<a name="*detailed*" /><p><b>*detailed*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Constant for <a href="#*debug*">*debug*</a>: Show detailed log output .</blockquote>
<blockquote>Initial value: <tt>300</tt></blockquote>
<a name="*egs*" /><p><b>*egs*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Transient noise parameter for ACT-UP procedures.

This is the expected gain s parameter. It specifies the s parameter
for the noise added to the utility values. It defaults to 0 which
means there is no noise in utilities.

See also: ACT-R parameter :egs</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*epl*" /><a name="*informational*" /><p><b>*informational*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Constant for <a href="#*debug*">*debug*</a>: Show informational and more important messages.</blockquote>
<blockquote>Initial value: <tt>100</tt></blockquote>
<a name="*iu*" /><p><b>*iu*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Initial procedure utility.

The initial utility value for a user-defined procedure (<a href="#defproc">defproc</a>). This is
the U(0) value for a production if utility learning is enabled and the
default utility if learning (<a href="#*ul*">*ul*</a>) is not enabled. The default value
is 0.

See also the function <a href="#assign-reward">assign-reward</a>.
See also: ACT-R parameter :iu</blockquote>
<blockquote>Initial value: <tt>0.0</tt></blockquote>
<a name="*le*" /><p><b>*le*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Latency Exponent parameter for declarative retrieval time calculation.
See ACT-R parameter :le</blockquote>
<blockquote>Initial value: <tt>1.0</tt></blockquote>
<a name="*lf*" /><p><b>*lf*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Latency Factor parameter for declarative retrieval time calculation.
See ACT-R parameter :lf</blockquote>
<blockquote>Initial value: <tt>1.0</tt></blockquote>
<a name="*mas*" /><a name="*maximum-associative-strength*" /><p><b>*maximum-associative-strength*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Maximum associative strength parameter for Declarative Memory.
<a href="#*mas*">*mas*</a> is defined as alias for <a href="#maximum-associative-strength">maximum-associative-strength</a>.
See also <a href="#*associative-learning*">*associative-learning*</a>, <a href="#reset-sji-fct">reset-sji-fct</a>.
See also: ACT-R parameter :mas.</blockquote>
<blockquote>Initial value: <tt>1.0</tt></blockquote>
<a name="*md*" /><p><b>*md*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>ACT-UP Partial Match Maximum Difference
Similarity penalty assigned when chunks are different
and no explicit similarity is set.
Value in activation (log) space.</blockquote>
<blockquote>Initial value: <tt>-1</tt></blockquote>
<a name="*mp*" /><p><b>*mp*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>ACT-UP Partial Match Scaling parameter
Mismatch (<a href="#set-similarities-fct">set-similarities-fct</a>) is linearly scaled using this coefficient.</blockquote>
<blockquote>Initial value: <tt>1.0</tt></blockquote>
<a name="*ms*" /><p><b>*ms*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>ACT-UP Partial Match Maximum Similarity
Similarity penalty assigned when chunks are equal.
Value in activation (log) space.</blockquote>
<blockquote>Initial value: <tt>0</tt></blockquote>
<a name="*nu*" /><p><b>*nu*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Utility assigned to compiled procedures.

This is the starting utility for a newly learned procedure (those created
by the production compilation mechanism). This is the U(0) value for
such a procedure if utility learning is enabled and the default utility if
learning is not enabled. The default value is 0.

See also the function <a href="#assign-reward">assign-reward</a> and the variable <a href="#*procedure-compilation*">*procedure-compilation*</a>.
See also: ACT-R parameter :nu</blockquote>
<blockquote>Initial value: <tt>0.0</tt></blockquote>
<a name="*ol*" /><p><b>*ol*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Optimized Learning parameter for base-level learning in Declarative Memory.
OL is always on in ACT-UP.
See also: ACT-R parameter :ol</blockquote>
<blockquote>Initial value: <tt>3</tt></blockquote>
<a name="*pas*" /><p><b>*pas*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Permanent noise parameter for declarative memory.
See also: ACT-R parameter :pas</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*procedure-compilation*" /><p><b>*procedure-compilation*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>If non-nil, procedure compilation is enabled.
Procedure compilation causes ACT-UP procedures defined with <a href="#defproc">defproc</a> to be compiled (or: cached).
After execution of a source procedure,  name, execution arguments and the result are stored as
compiled procedure.  The compiled procedure is added to each of the source procedure's groups.

When the group is executed, compiled procedures compete for execution with the other procedures in the group.  (The procedure with the highest utility is chosen.)

The initial utility of a compiled procedure equals the initial utility of the source procedure.  When a source procedure is compiled multiple times, the utility of the compiled procedure is updated by assigning the source procedure utility as reward to the compiled procedure (according to the ACT-R difference learning equation).  See also <a href="#assign-reward">assign-reward</a> for reward assignment to regular procedures.

<a href="#*epl*">*epl*</a> is defined as alias for <a href="#*procedure-compilation*">*procedure-compilation*</a>.</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*rt*" /><p><b>*rt*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Retrieval Threshold parameter for declarative memory.
Chunks with activation lower than <a href="#*rt*">*rt*</a> are not retrieved.
See also: ACT-R parameter :rt</blockquote>
<blockquote>Initial value: <tt>0.0</tt></blockquote>
<a name="*ul*" /><p><b>*ul*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Utility learning flag.

If this is set to t, then the utility learning equation used above
will be used to learn the utilities as the model runs. If it is set to
nil then the explicitly set utility values for the procedures are
used (though the noise will still be added if <a href="#*egs*">*egs*</a> is
non-zero). The default value is nil.

See also the function <a href="#assign-reward">assign-reward</a>.
Only if <a href="#assign-reward">assign-reward</a> is called will this parameter have any effect.

See also: ACT-R parameter :ul</blockquote>
<blockquote>Initial value: <tt>T</tt></blockquote>
<a name="*ut*" /><p><b>*ut*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Utility threshold.

This is the utility threshold. If it is set to a number then that is
the minimum utility value that a procedure must have to compete in
conflict resolution. Procedures with a lower utility value than that
will not be selected. The default value is nil which means that there
is no threshold value and all procedures will be considered.

See also: ACT-R parameter :ut</blockquote>
<blockquote>Initial value: <tt>NIL</tt></blockquote>
<a name="*warning*" /><p><b>*warning*</b>&nbsp;&nbsp;&nbsp;<i>variable</i></p>
<blockquote>Constant for <a href="#*debug*">*debug*</a>: Show warnings and more important messages.</blockquote>
<blockquote>Initial value: <tt>10</tt></blockquote>
<a name="actup-chunk" /><p><b>actup-chunk</b>&nbsp;&nbsp;&nbsp;<i>structure</i></p>
<blockquote>Type defining an ACT-UP chunk.
Derive your own chunks using this as a base structure
by using <a href="#define-chunk">define-chunk</a>.</blockquote><a name="actup-time" /><p>(<b>actup-time</b> &optional meta-process)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Returns the current runtime.
An optional parameter META-PROCESS specifies the meta-process to use.
It defaults to the current meta-process.</blockquote><a name="add-chunk-to-dm" /><p>(<b>add-chunk-to-dm</b> chunk first-presentation-time recent-presentation-times number-of-presentations)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Add CHUNK to declarative memory of current model.
FIRST-PRESENTATION-TIME indicates the time of first presentation of the chunk (see also <a href="#actup-time">actup-time</a>).
RECENT-PRESENTATION-TIMES is a list of the <a href="#*ol*">*ol*</a> or less most recent presentation times.
NUMBER-OF-PRESENTATIONS indicates the total number of presentation, including the first one.</blockquote><a name="add-sji-fct" /><p>(<b>add-sji-fct</b> list)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Set Sji link weights between chunks.
LIST is a list with elements of form (CJ NI S), where CJ und NI are
chunks or chunk names, and S is the new link weight, regulating
spreading activation when CI is in context as a cue and NI is
retrieved.  S may also be a list of form (FCN TIME), with FCN
indicating frequency of C and N occurring together, and TIME
indicating the point in time of their last joint occurrence (TIME is
unused currently, but must be given.)</blockquote><a name="assign-reward" /><p>(<b>assign-reward</b> reward)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Assign reward to recently invoked procedures.
Distributes reward value REWARD across the recently invoked procedures.
See parameters <a href="#*au-rpps*">*au-rpps*</a>, <a href="#*au-rfr*">*au-rfr*</a>, <a href="#*alpha*">*alpha*</a>, and <a href="#*iu*">*iu*</a>.
See <a href="#defproc">defproc</a> for documentation on how to use utility when
selecting between procedures.

Reward must be greater than 0.

The reward is only distributed to procedures invoked since the last call to
<a href="#assign-reward">assign-reward</a> (or <a href="#flush-procedure-queue">flush-procedure-queue</a>, or <a href="#reset-model">reset-model</a>).  See also
<a href="#assign-reward*">assign-reward*</a> for a function that does not reset this set of
procedures.</blockquote><a name="assign-reward*" /><p>(<b>assign-reward*</b> reward)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Like <a href="#assign-reward">assign-reward</a>, but does not flush the procedure queue.
Only reward portions >0 are assigned to procedures, i.e., if
<a href="#*au-rfr*">*au-rfr*</a> or <a href="#*au-rpps*">*au-rpps*</a> are nil (ACT-R 6 reward propagation),
rewards are only assigned to procedures up to <a href="#reward">reward</a> seconds back in time.
See also <a href="#flush-procedure-queue">flush-procedure-queue</a>.</blockquote><a name="best-chunk" /><p>(<b>best-chunk</b> confusion-set &key cues soft-spec timeout inhibit-cues)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Retrieves the best chunk in confusion set.
CONFUSION-SET is a list of chunks, out of which the chunk is returned.
CUES is a list of cues that spread activation.  CUES may contain
chunk objects or names of chunks.
SOFT-SPEC: request specification for partial matching (see also <a href="#retrieve-chunk">retrieve-chunk</a>).
INHIBIT-CUES: do not use (yet).

Simulates timing behavior with <a href="#pass-time">pass-time</a>.

Marks the chunk as recently retrieved (declarative finst).

Note that this function extends beyond the power of ACT-R's
declarative module.

See also the higher-level function <a href="#retrieve-chunk">retrieve-chunk</a>.</blockquote><a name="blend" /><p>(<b>blend</b> chunks &key cues chunk-type retrieval-spec)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Return a blended variant of chunks.
Activation is calculated using spreading activation from CUES.  CUES
may contain chunk objects or names of chunks.  The returned chunk is
of type CHUNK-TYPE; all CHUNKS must be of type CHUNK-TYPE or of a
supertype thereof.  If CHUNK-TYPE is not given, all CHUNKS must be of
the same class and the returned type will be this class.
RETRIEVAL-SPEC should contain the retrieval filter used to obtain
CHUNKS; attribute-value pairs in it will be included in the returned
chunk as-is and not be blended from the CHUNKS.

See also the higher-level function <a href="#blend-retrieve-chunk">blend-retrieve-chunk</a>.</blockquote><a name="blend-retrieve-chunk" /><p>(<b>blend-retrieve-chunk</b> spec &key cues soft-spec recently-retrieved)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Retrieve a blended chunk from declarative memory.
The blended chunk is a new chunk represeting the chunks
retrievable from declarative memory under specification SPEC.
The contents of the blended chunk consist of a weighted average
of the retrievable chunks, whereas each chunk is weighted
according to its activation.

CUES is, if given, a list of chunks that spread activation
to facilitate the retrieval of target chunks. CUES may contain
chunk objects or names of chunks.

SOFT-SPEC is, if given, a retrieval specification whose 
constraints are soft; partial matching is used for this portion
of the retrieval specification. 

SPEC and SOFT-SPEC are lists of the form (:slot1 value1 :slot2
value2 ...), or (slot1 value1 slot2 value2).</blockquote><a name="chunk-name" /><p>(<b>chunk-name</b> chunk)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>The unique name of CHUNK.
The returned value is a symbol assigned as unique name of CHUNK
in the current model.</blockquote><a name="chunk-type" /><a name="current-model" /><p>(<b>current-model</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Evaluates to the currently active ACT-UP model.</blockquote><a name="debug-clear" /><p>(<b>debug-clear</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Clear the ACT-UP debug log buffer.</blockquote><a name="debug-detail" /><p>(<b>debug-detail</b> &body body)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Evaluates BODY while outputting ACT-UP debug information.</blockquote><a name="debug-detail*" /><p>(<b>debug-detail*</b> &body body)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Evaluates BODY while logging ACT-UP debug information.
The log output can be retrieved with <a href="#debug-log">debug-log</a>.</blockquote><a name="debug-grep" /><p>(<b>debug-grep</b> keyword &body body)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Evaluates BODY while outputting ACT-UP debug information.</blockquote><a name="debug-log" /><p>(<b>debug-log</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Returns logged ACT-R output.
If <a href="#*debug-to-log*">*debug-to-log*</a> is set to t, the ACT-UP debug log may be
retrieved using this function.</blockquote><a name="define-chunk-type" /><p>(<b>define-chunk-type</b> type &rest members)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Define a chunk type of name TYPE.
MEMBERS should contain all possible elements of the chunk type.
TYPE may be a symbol or a list of form (name2 :include parent-type),
whereas PARENT-TYPE refers to another defined chunk type whose
elements will be inherited.
MEMBERS may be a list of symbols, or also a list of member
specifiers as used with the lisp <a href="#defstruct">defstruct</a> macro, which see.
<pre>
  </pre>
Chunks make be created by invoking the make-TYPE function, whereas
TYPE stands for the name of the chunk type as defined with this
macro. An attribute called <a href="#:name">:name</a> should be included to specify the
unique name of the chunk (the name may not be used for any other chunk
in the model). 

Chunk contents must not be changed after a chunk has been created.

An additional function of name make-TYPE* is also provided, which
creates a new chunk just like make-TYPE does, but only if such a chunk
does not yet exist in declarative memory (of the current model). All
slot values of the chunks are used in the comparison (unspecified ones
at their default values), except the :name attribute.  If a matching
chunk is found in DM, it is returned.</blockquote><a name="define-slots" /><p>(<b>define-slots</b> &rest slot-names)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Define slots to be used in chunks of this process.
Only slot names defined using this macro may be used in chunks.
Overrides any slot set defined earlier.</blockquote><a name="defproc" /><p>(<b>defproc</b> name args &rest body)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Define an ACT-UP procedure.
The syntax follows the Lisp <a href="#defun">defun</a> macro, except that 
some keyword-argument parameters may follow ARGS
at the beginning of BODY.

This macro will define a Lisp function of name NAME with
arguments ARGS.  The Lisp function will execute the Lisp
forms in BODY and return the value of the last form.

The known parameters are:

<pre>
 :GROUP the-group</pre>
A :group parameter defines one or or a list of procedure
groups that the procedure will belong to.  All procedures defined as part of a
group must have the same argument footprint.


If GROUP is given, a function of name GROUP will also be
defined that invokes one of the procedures assigned to GROUP.
For example:

<pre>
 (defproc subtract-digit-by-addition (minuend subtrahend)
   :group subtract
   "Perform subtraction of a single digit via addition."
   (let ((chunk (retrieve-chunk #96;(:chunk-type addition-fact
                                  :result ,minuend
                                  :add1 ,subtrahend))))
       (if chunk (addition-fact-add2 chunk))))
 (defproc subtract-digit-by-decrement (minuend subtrahend)
   :group subtract
   "Perform subtraction of a single digit via subtraction knowledge."
   ...)</pre>

These procedures can be invoked via a function call such as

<pre>
 (subtract 5 2)</pre>

ACT-UP will choose the procedure that has the highest utility.  See
<a href="#assign-reward">assign-reward</a> for manipulation of utilities (reinforcement
learning), and <a href="#*procedure-compilation*">*procedure-compilation*</a> for in-theory compilation of
procedures (routinization, internalization).

<pre>
 :INITIAL-UTILITY u</pre>

The :initial-utility parameter sets the utility that this procedure receives when it is created or the model is reset.
If not given, the initial utility will be the value of <a href="#*iu*">*iu*</a> at time of first invocation.

Procedure utilities, wether initial or acquired through rewards are always specific to the model.

Procedures and groupings of procedures are not specific to the model.</blockquote><a name="defrule" /><p>(<b>defrule</b> args)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Alias for <a href="#defproc">defproc</a>.
This is provided for compatibility with some early published examples
of ACT-UP code.  Please use <a href="#defproc">defproc</a> instead.</blockquote><a name="explain-activation" /><p>(<b>explain-activation</b> chunk-or-name &optional cues retr-spec)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Returns a string with an explanation of the evaluation of CHUNK.
CUES contains retrieval cues spreading activation.
RETR-SPEC describes the retrieval specification for partial matching retrievals.</blockquote><a name="filter-chunks" /><p>(<b>filter-chunks</b> chunk-set spec &key recently-retrieved)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Filter chunks according to SPEC.
SPEC is a list of the form (:slot1 value1 :slot2 value2 ...),
or (slot1 value1 slot2 value2).
CHUNK-SET is the list of chunks to be filtered (1), or an associative array (2)
of the form ((X . chunk1) (Y . chunk2) ...).
returns a list of chunks in case (1) and a list of conses in case (2).</blockquote><a name="flush-procedure-queue" /><p>(<b>flush-procedure-queue</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Empties the queue of procedures in the current model.
This resets the list of procedures to which rewards can be distributed (see
<a href="#assign-reward">assign-reward</a> and <a href="#assign-reward*">assign-reward*</a>).</blockquote><a name="learn-chunk" /><p>(<b>learn-chunk</b> chunk &key co-presentations)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Learn chunk CHUNK.

This will note a presentation of a chunk in the model's DM.
If the chunk does not already exist in DM, it is added.

To create or obtain the chunk from a attribute-value specification,
use <a href="#make-chunk">make-chunk</a> and <a href="#make-chunk*">make-chunk*</a> (or their corresponding constructor 
functions for a specific chunk type - see <a href="#define-chunk-type">define-chunk-type</a>), then
apply <a href="#learn-chunk">learn-chunk</a> on the result.

Returns the added chunk.</blockquote><a name="make-chunk" /><p>(<b>make-chunk</b> &rest args)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Create an ACT-UP chunk.
Arguments should consist of named chunk feature values: ARGS is a list
of the form (:name1 val1 :name2 val2 ...), whereas names correspond to
slot names as defined with <a href="#define-slots">define-slots</a>.  

An attribute called <a href="#:name">:name</a> should be included to specify the unique
name of the chunk (the name may not be used for any other chunk in
the model). 

If chunk types are defined with <a href="#define-chunk-type">define-chunk-type</a>, then use the
<a href="#make-TYPE">make-TYPE</a> syntax instead.</blockquote><a name="make-chunk*" /><p>(<b>make-chunk*</b> &rest args)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Like <a href="#make-chunk">make-chunk</a>, but returns matching chunk from declarative memory if one exists.

Arguments should consist of named chunk feature values: ARGS is a list
of the form (:name1 val1 :name2 val2 ...), whereas names correspond to
slot names as defined with <a href="#define-slots">define-slots</a>.  

An attribute called <a href="#:name">:name</a> should be included to specify the 
name of the chunk. Comparing the proposed chunks (in ARGS) to the existing
chunks in Declarative Memory, the names of the chunks are ignored.

The purpose of this function lies in the ability to boost a chunk existing in DM, when its contents are already known. For example:

<pre>
 (reset-model)
 (learn-chunk (make-chunk* :one 1 :two 2))
 (learn-chunk (make-chunk* :one 1 :two 2))</pre>

will create a chunk (first call), and then boost it, while

<pre>
 (learn-chunk (make-chunk :one 1 :two 2))</pre>

will always create new chunk and add it to declarative memory.

If chunk types are defined with <a href="#define-chunk-type">define-chunk-type</a>, then use the
<a href="#make-TYPE*">make-TYPE*</a> syntax instead.</blockquote><a name="make-meta-process" /><p>(<b>make-meta-process</b> &key actup-time name)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Create a new ACT-UP meta-process.
NAME, if given, specifies a name.
The meta process keeps track of simulation time.
See also <a href="#meta-process">meta-process</a> and <a href="#*current-actup-meta-process*">*current-actup-meta-process*</a>.</blockquote><a name="make-model" /><p>(<b>make-model</b> &key name parms pm dm modules time)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Create a new ACT-UP model.
NAME, if given, specifies a name.</blockquote><a name="meta-process" /><p><b>meta-process</b>&nbsp;&nbsp;&nbsp;<i>structure</i></p>
<blockquote>An ACT-UP meta process.
A meta process keeps track of time for one or more models.</blockquote><a name="meta-process-name" /><p>(<b>meta-process-name</b> x)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Return the name of an ACT-UP meta-process.
See also <a href="#meta-process">meta-process</a> and <a href="#*current-actup-meta-process*">*current-actup-meta-process*</a>.</blockquote><a name="model-chunks" /><p>(<b>model-chunks</b> &optional model)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Evaluates to the list of chunks in the given model MODEL.</blockquote><a name="model-name" /><p>(<b>model-name</b> x)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Return the name of an ACT-UP model.</blockquote><a name="non-nil" /><a name="pass-time" /><p>(<b>pass-time</b> seconds &optional meta-process)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Simulates the passing of time.
An optional parameter META-PROCESS specifies the meta-process to use.
It defaults to the current meta-process.</blockquote><a name="pc" /><p>(<b>pc</b> obj &key stream internals)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Print a human-readable representation of chunk OBJ.
STREAM, if given, indicates the stream to which output is sent.
INTERNALS, if given and t, causes <a href="#pc">pc</a> to print architectural
internals (see also <a href="#pc*">pc*</a> for a shortcut).</blockquote><a name="pc*" /><p>(<b>pc*</b> obj &key stream)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Print a human-readable representation of chunk OBJ, including architectural internals.
STREAM, if given, indicates the stream to which output is sent.</blockquote><a name="reset-actup" /><p>(<b>reset-actup</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Resets architectural ACT-UP parameters, meta-process and current model.</blockquote><a name="reset-model" /><p>(<b>reset-model</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Resets the current ACT-UP model. 
All declarative memory and all subsymbolic knowledge is deleted.
Global parameters (dynamic, global Lisp variables) are retained, as are
functions and model-independent procedures.</blockquote><a name="reset-mp" /><p>(<b>reset-mp</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Resets the current Meta process. 
Resets the time in the meta process.</blockquote><a name="reset-sji-fct" /><p>(<b>reset-sji-fct</b> chunk)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Removes all references to CHUNK from all other chunks in the current model.</blockquote><a name="retrieve-chunk" /><p>(<b>retrieve-chunk</b> spec &key cues soft-spec timeout recently-retrieved)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Retrieve a chunk from declarative memory.
The retrieved chunk is the most highly active chunk among those in
declarative memory that are retrievable and that conform to
specification SPEC.

CUES is, if given, a list of chunks that spread activation
to facilitate the retrieval of a target chunk.  CUES may contain
chunk objects or names of chunks.

SOFT-SPEC is, if given, a retrieval specification whose 
constraints are soft; partial matching is used for this portion
of the retrieval specification. 

SPEC and SOFT-SPEC are lists of the form (:slot1 value1 :slot2
value2 ...), or (slot1 value1 slot2 value2).

TIMEOUT, if given, specifies the maximum time allowed before
the retrieval fails.

RECENTLY-RETRIEVED, if given, may be either <a href="#t">t</a>, in which case
the retrieved chunk must have a declarative finst (i.e., has been
recently retrieved), or <a href="#nil">nil</a>, in which is must not have a finst.
See also <a href="#*declarative-num-finsts*">*declarative-num-finsts*</a> and <a href="#*declarative-finst-span*">*declarative-finst-span*</a>.</blockquote><a name="set-base-level-fct" /><p>(<b>set-base-level-fct</b> chunk value &optional creation-time)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Set base levels of CHUNK.
If CREATION-TIME is specified, it contains the time at which the chunk
was created in declarative memory, and VALUE contains the number of
presentations (an integer value).  If TIME is not specified, VALUE is
the chunk's absolute activation value (log space).

For plausibility reasons, models should specify presentations and time
when possible.</blockquote><a name="set-base-levels-fct" /><p>(<b>set-base-levels-fct</b> list)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Set base levels of several chunks.
ACT-R compatibility function.
LIST contains elements of form (CHUNK PRES TIME) or (CHUNK ACT),
whereas CHUNK is a chunk object or the name of a chunk,
PRES is a number of past presentations (integer),
and TIME the life time of the chunk,
and ACT the chunk's absolute activation.

For plausibility reasons, models should not use the ACT form when
possible.</blockquote><a name="set-current-model" /><p>(<b>set-current-model</b> new-model)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Switches the currently active ACT-UP model.
See also <a href="#current-model">current-model</a> and <a href="#with-current-model">with-current-model</a>.</blockquote><a name="set-dm-total-presentations" /><p>(<b>set-dm-total-presentations</b> npres)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Set the count of total presentations of all chunks in DM.
This value is relevant for associative learning (Sji/Rji).</blockquote><a name="set-similarities-fct" /><p>(<b>set-similarities-fct</b> list)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Set similarities between chunks.
LIST is a list with elements of form (A B S), where A und B are
chunks or chunk names, and S is the new similarity of A and B.
For example:

<pre>
 (set-similarities-fct &#39;((dave david -0.05) 
                         (steve hank -0.1)  
                         (mary john -0.9)))</pre></blockquote><a name="show-chunks" /><p>(<b>show-chunks</b> &optional constraints)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Prints all chunks in model MODEL subject to CONSTRAINTS.
See the function <a href="#filter-chunks">filter-chunks</a> for a description of possible constraints.</blockquote><a name="show-parameters" /><p>(<b>show-parameters</b> &optional show-all)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Print architectural ACT-UP parameters different from their defaults.
If SHOW-ALL is non-nil, print even unchanged parameters.</blockquote><a name="show-utilities" /><p>(<b>show-utilities</b>)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Prints a list of all utilities in the current model.</blockquote><a name="stop-actup-time" /><p>(<b>stop-actup-time</b> &body body)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Returns execution time of BODY in current ACT-UP model.
Evaluates BODY.  See also <a href="#actup-time">actup-time</a>.</blockquote><a name="wait-for-model" /><p>(<b>wait-for-model</b> &optional model)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Waits until meta-process and MODEL are synchronized.
When a model is run with a new meta-process, it can happen that
the meta-process time is behind the model's time (since the model
was operated with a different meta-process before).

This will generate warnings or errors.

This function waits (see <a href="#pass-time">pass-time</a>) until the model is ready, that
is, it sets the meta process time to the model time if the model time
is more advanced, plus the current value of <a href="#*dat*">*dat*</a>.
MODEL defaults to the current model.</blockquote><a name="with-current-model" /><p>(<b>with-current-model</b> model &body body)&nbsp;&nbsp;&nbsp;<i>function</i></p>
<blockquote>Execute forms in BODY with the ACT-UP model MODEL being current.
See also <a href="#current-model">current-model</a> and <a href="#set-current-model">set-current-model</a>.</blockquote><font size=-1><p>Documentation generated by <a href="http://homepage.mac.com/svc/lispdoc/">lispdoc</a> running on Clozure Common Lisp</p></font></body></html>